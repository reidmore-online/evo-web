export interface Input extends Marko.HTML.Input {
    multiline?: boolean;
    type?: Marko.HTML.Input["type"];
    inputSize?: "regular" | "large";
    fluid?: boolean;
    opaqueLabel?: boolean;
    floatingLabel?: string;
    floatingLabelStatic?: boolean;
    prefixIcon?: Marko.AttrTag<{ content: Marko.Body }>;
    prefixText?: Marko.AttrTag<{ content: Marko.Body }>;
    postfixText?: Marko.AttrTag<{ content: Marko.Body }>;
    postfixIcon?: Marko.AttrTag<{
        content: Marko.Body;
        "aria-label"?: Marko.HTMLAttributes["aria-label"];
    }>;
    invalid?: boolean;
    a11yButtonLabel?: Marko.HTMLAttributes["aria-label"];
    autocorrect?: Marko.HTML.TextArea["autocorrect"];
    cols?: Marko.HTML.TextArea["cols"];
    rows?: Marko.HTML.TextArea["rows"];
}

<const/{
    a11yButtonLabel,
    class: inputClass,
    disabled,
    floatingLabel,
    floatingLabelStatic,
    fluid,
    id,
    inputSize,
    invalid,
    multiline,
    opaqueLabel,
    postfixIcon,
    prefixIcon,
    style,
    type,
    placeholder = "",
    prefixText,
    postfixText,
    readonly,
    onBlur,
    onFocus,
    ...htmlInput
}=input>

<const/isPostfix=!!postfixIcon>
<const/hasIcon=prefixIcon || isPostfix>
<const/isLarge=inputSize === "large">
<const/displayIcon=!multiline && hasIcon>
<id/prefixId>
<id/postfixId>
<id/textboxId=id>
<const/defaultTag=(fluid ? "div" : "span")>
<let/focused=false>
<let/value:=input.value>
<const/currentPlaceholder=(placeholder && focused && !value ? placeholder : "")>
<const/disablePrefix=!!floatingLabel && !floatingLabelStatic>

<evo-floating-label
    floatingLabel=floatingLabel
    inputSize=inputSize
    opaqueLabel=opaqueLabel
    id=textboxId
    disabled=disabled
    invalid=invalid
    fluid=fluid
    value=value
    focused=focused
>
   <${defaultTag}
        style=style
        placeholder=currentPlaceholder
        class=[
            "textbox" /** start remove after `:has` support */,
            disabled && "textbox--disabled",
            invalid && "textbox--invalid",
            readonly &&
                "textbox--readonly" /** end remove after `:has` support */,
            isLarge && "textbox--large",
            fluid && "textbox--fluid",
            inputClass,
        ]>
        <if=displayIcon && prefixIcon && !disablePrefix>
            <${prefixIcon}/>
        </if>
        <if=prefixText && !disablePrefix>
            <span ...prefixText id=prefixId/>
        </if>
        <${multiline ? "textarea" : "input"}
            aria-describedby=(
                [prefixId, postfixId].filter(Boolean).join(" ") || undefined
            )
            onBlur(e: Event, target: HTMLInputElement) {
                focused = false;
                onBlur && onBlur(e, target);
            }
            onFocus(e: FocusEvent, target: HTMLInputElement) {
                focused = true;
                onFocus && onFocus(e, target);
            }
            ...htmlInput
            id=textboxId
            class="textbox__control"
            type=!multiline && (type || "text")
            value:=value
            disabled=disabled
            aria-invalid=invalid && "true"
            readonly=readonly/>
        <if=postfixText>
            <span ...postfixText id=postfixId/>
        </if>
        <if=displayIcon && postfixIcon>
            <${postfixIcon["aria-label"] && "button"}
                class=["icon-btn icon-btn--transparent"]
                type="button"
                disabled=disabled
                ...postfixIcon>
                <${postfixIcon}/>
            </>
        </if>
    </>
</>
